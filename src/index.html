<svelte:window on:click="close()" />
<div on:click="event.stopPropagation()" class="autocomplete">
  <input 
    type="text" 
    class="{class}"
    {name}
    {placeholder}
    {required}
    {disabled}
    value="{value || ''}"
    autocomplete="{name}" 
    bind:value="search"
    on:input="onChange(event)"
    on:focus="fire('focus', event)"
    on:blur="fire('blur', event)"
    on:keydown="onKeyDown(event)"
    ref:input
  >
  <ul class="autocomplete-results{!isOpen ? ' hide-results' : ''}" ref:list>
{#each suggestions as result, i}
    <li on:click="close(i)" class="autocomplete-result{ i === arrowCounter ? ' is-active' : '' }">
    {@html result.label}
    </li>
{/each}
  </ul>
{#if isLoading}
  <slot>
    <p class="fallback">Loading data...</p>
  </slot>
{/if}
</div>

<script>

const regExpEscape = (s) => {
  return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&")
}

export default {
  data () {
    return {
      name: '',
      class: '',
      value: '',
      placeholder: '',
      required: false,
      disabled: false,

      // autocomplete props
      items: [],
      isOpen: false,
      suggestions: [],
      search: '',
      isLoading: false,
      arrowCounter: 0,

      // options
      isAsync: false,
      minChar: 2,
      maxItems: 10,
      fromStart: true, // Default type ahead
    }
  },
  methods: {
    async onChange (event) {

      const { value } = event.target
      if (value) {
        this.fire('input', value)
      }

      const { isAsync, search, minChar } = this.get()

      // Is the data given by an outside ajax request?
      if (this.get().isAsync) {
        this.set({ isLoading: true })        
      } else {
        if (search.length >= Number(minChar)) {
          this.filterResults()
          this.set({ isOpen: true })
        }
      }
    },
    filterResults () {
      const { items, search, fromStart, maxItems } = this.get()
      const results = items.filter(item => {
        if (typeof item !== 'string') {
          item = item.key || '' // Silent fail
        }
        if (fromStart) {
          return item.toUpperCase().startsWith(search.toUpperCase())
        }
        return item.toUpperCase().includes(search.toUpperCase())
      })
      const suggestions = results.map(item => {
        const text = typeof item !== 'string' ? item.key : item
        return {
          key: text,
          value: item.value || item,
          label: search.trim() === '' ? text : text.replace(RegExp(regExpEscape(search.trim()), 'i'), "<span>$&</span>")
        }
      })
      this.set({ suggestions })
      const height = suggestions.length > maxItems ? maxItems : suggestions.length
      this.refs.list.style.height = `${height * 2.25}rem`
    },
    onKeyDown (event) {
      let { arrowCounter, suggestions } = this.get()
      if (event.keyCode === 40) {
        // ArrowDown
        if (arrowCounter < suggestions.length) {
          this.set({ arrowCounter: arrowCounter + 1 })
        }
      } else if (event.keyCode === 38) {
        // ArrowUp
        if (arrowCounter > 0) {
          this.set({ arrowCounter: arrowCounter - 1 })
        }
      } else if (event.keyCode === 13) {
        // Enter
        event.preventDefault()
        if (arrowCounter === -1) {
          arrowCounter = 0 // Default select first item of list
        }
        this.close(arrowCounter)
      } else if (event.keyCode === 27) {
        // Escape
        event.preventDefault()
        this.close()
      }
    },
    close (index = -1) {
      if (index > -1) {
        const { suggestions } = this.get()
        const { key, value } = suggestions[index]
        this.fire('change', value)
        this.set({ value, search: key })
      } else if (!this.get().value) {
        this.set({ value: '', search: '' })
      }
      this.set({ isOpen: false, arrowCounter: -1 })
      this.refs.input.blur()
    }
  },
  onupdate ({ changed, current, previous }) {
    if (this.get().isAsync && changed.items && current.items.length) {
      this.set({
        items: current.items,
        isLoading: false,
        isOpen: true
      })
      this.filterResults()
    }
  }
}
</script>

<style>
  * {
    box-sizing: border-box;
  }

  input {
    height: 2rem;
    font-size: 1rem;
    padding: 0.25rem 0.5rem;
  }

  .autocomplete {
    position: relative;
  }

  .hide-results {
    display: none;
  }

  .autocomplete-results {
    padding: 0;
    margin: 0;
    border: 1px solid #dbdbdb;
    height: 6rem;
    overflow: auto;
    width: 100%;

    background-color: white;
    box-shadow: 2px 2px 24px rgba(0, 0, 0, 0.1);
    position: absolute;
    z-index: 100;
  }

  .autocomplete-result {
    color: #7a7a7a;
    list-style: none;
    text-align: left;
    height: 2rem;
    padding: 0.25rem 0.5rem;
    cursor: pointer;
  }

  .autocomplete-result > :global(span) {
    background-color: none;
    color: #242424;
    font-weight: bold;
  }

  .autocomplete-result.is-active,
  .autocomplete-result:hover {
    background-color: #dbdbdb;
  }
</style>
